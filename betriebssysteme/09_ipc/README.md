# Chapter 9: Inter-Process Communication (IPC)

In this chapter, we will explore various inter-process communication (IPC) mechanisms in Unix-like operating systems. We will cover signals, semaphores, shared memory, message queues, pipes, FIFOs, and sockets.

The following programs are used to demonstrate the concepts:

* `signals.c`: Demonstrates how to handle signals in a C program.
* `semaphore.c`: Demonstrates how to use semaphores to synchronize access to a shared resource.
* `shared_memory.c`: Demonstrates how to use shared memory to allow multiple processes to access the same memory space.
* `message_queue.c`: Demonstrates how to use message queues to send messages between processes.
* `pipe.c`: Demonstrates how to use pipes to send data between processes.
* `fifo.c`: Demonstrates how to use FIFOs to send data between processes.
* `socket.c`: Demonstrates how to use sockets to send data between processes over a network.

More information about the programs can be found in the source code files and the paragraphs below.

If you want to compile the programs at once, you can use the provided Makefile:

```bash
# Compile all programs
make
# Clean up
make clean
```

## 9.1 Signals

The `signals.c` program demonstrates how to handle signals in a C program. It creates a child process that sends a signal (SIGINT) to its parent process after a brief pause. The parent process registers a signal handler to catch the SIGINT signal, which is typically generated by pressing Ctrl+C in the terminal. When the signal is received, the handler function is invoked, printing a message indicating the receipt of the signal. This program serves as an educational example of inter-process communication through signals and showcases the use of the `signal` and `kill` functions from the POSIX standard library. 

### Key Features:
- Registers a signal handler for SIGINT.
- Demonstrates the use of `fork()` to create a child process.
- Uses `kill()` to send a signal from the child to the parent.
- Utilizes `pause()` to wait for signals in the parent process.

### Usage

```bash
# Compile the program
gcc signals.c -o signals
# Run the program
./signals
```

### Expected Output

```bash
Parent waiting for signal...
Signal 2 received
```

## 9.2 Semaphores

The `semaphore.c` program demonstrates how to use semaphores to synchronize access to a shared resource. It creates a child process and sends a signal to it. The parent process registers a signal handler to catch the SIGINT signal, which is typically generated by pressing Ctrl+C in the terminal. When the signal is received, the handler function is invoked, printing a message indicating the receipt of the signal. This program serves as an educational example of inter-process communication through signals and showcases the use of the `signal` and `kill` functions from the POSIX standard library. 

### Key Features:
- Demonstrates the use of semaphores to synchronize access to a shared resource.
- Uses `sem_init()` to initialize the semaphore.
- Uses `sem_wait()` and `sem_post()` to synchronize access to the shared resource.
- Utilizes `pthread_create()` to create multiple threads.

### Usage

```bash
# Compile the program
gcc semaphore.c -o semaphore -pthread
# Run the program
./semaphore
```

### Expected Output

```bash
# The counter should be 5000 as we have 5 threads incrementing the counter 1000 times each.
Final counter value: 5000   
```

## 9.3 Shared Memory

The `shared_mem.c` program demonstrates the use of shared memory for inter-process communication between a parent and child process in C. The program creates a shared memory segment that both processes can access. The parent process writes a message to the shared memory, while the child process reads from it after writing its own message. The program utilizes system calls such as `shmget` to create the shared memory segment, `shmat` to attach it to the process's address space, and `shmdt` to detach it once the communication is complete. Finally, the parent process cleans up by destroying the shared memory segment using `shmctl`. This example serves as an educational tool for understanding shared memory concepts and their practical application in C programming.

### Key Features:
- Demonstrates the creation and use of shared memory segments.
- Illustrates inter-process communication between a parent and child process.
- Utilizes system calls for managing shared memory (`shmget`, `shmat`, `shmdt`, `shmctl`).
- Cleans up resources by destroying the shared memory segment after use.

### Usage

```bash
# Compile the program
gcc shared_mem.c -o shared_mem
# Run the program
./shared_mem
```

### Expected Output

```bash
# The shared memory should contain the messages sent by the parent and child processes.
Parent wrote: Hello from parent process!
        Child wrote: Hello from child process!
```

## 9.4 Message Queue

The `message_queue.c` program demonstrates the use of message queues for inter-process communication (IPC) in C. It creates a message queue, forks a child process, and facilitates communication between the parent and child processes using the message queue. The parent process sends a message to the child process, which then receives and prints the message.

### Key Features:
- **Inter-Process Communication**: Utilizes message queues to enable communication between a parent and child process.
- **Message Structure**: Defines a structure for messages that includes a message type and message text.
- **Message Sending and Receiving**: Implements functions to send and receive messages using `msgsnd` and `msgrcv`.
- **Message Queue Management**: Creates and destroys the message queue using `msgget` and `msgctl`.

### Usage:

```bash
# Compile the program
gcc message_queue.c -o message_queue
# Run the program
./message_queue
```

### Expected Output:
When the program is executed, the expected output will be:
```
Parent sent: Hello from message queue!
    Child received: Hello from message queue!
```
The parent process sends a message to the message queue, and the child process receives and prints the message, demonstrating successful inter-process communication.

## 9.5 Pipes

The `pipe.c` program demonstrates how to use pipes to send data between processes. It creates a pipe, forks a child process, and facilitates communication between the parent and child processes using the pipe. The parent process writes a message to the pipe, while the child process reads from it after writing its own message. The program utilizes system calls such as `pipe()` to create the pipe, `fork()` to create the child process, and `read()` and `write()` to send and receive data through the pipe. This example serves as an educational tool for understanding pipes and their practical application in C programming.

### Key Features:
- Demonstrates the creation and use of pipes.
- Illustrates inter-process communication between a parent and child process.
- Utilizes system calls for managing pipes (`pipe()`, `fork()`, `read()`, `write()`).
- Cleans up resources by closing the pipe after use.

### Usage

```bash
# Compile the program
gcc pipe.c -o pipe
# Run the program
./pipe
```

### Expected Output

```bash
# The pipe should contain the messages sent by the parent and child processes.
Parent wrote: Hello from parent process!
        Child wrote: Hello from child process!
```

## 9.6 FIFOs

The `fifo.c` program demonstrates how to use FIFOs to send data between processes. It creates a FIFO, forks a child process, and facilitates communication between the parent and child processes using the FIFO. The parent process writes a message to the FIFO, while the child process reads from it after writing its own message. The program utilizes system calls such as `mkfifo()` to create the FIFO, `fork()` to create the child process, and `read()` and `write()` to send and receive data through the FIFO. This example serves as an educational tool for understanding FIFOs and their practical application in C programming.

### Key Features:
- Demonstrates the creation and use of FIFOs.
- Illustrates inter-process communication between a parent and child process.
- Utilizes system calls for managing FIFOs (`mkfifo()`, `fork()`, `read()`, `write()`).
- Cleans up resources by destroying the FIFO after use.

### Usage

```bash
# Compile the program
gcc fifo.c -o fifo
# Run the program
./fifo
```

### Expected Output

```bash
# The FIFO should contain the messages sent by the parent and child processes.
Parent wrote: Hello from parent process!
        Child wrote: Hello from child process!
```

## 9.7 Sockets

The `socket.c` program demonstrates how to use sockets to send data between processes over a network. It creates a socket, forks a child process, and facilitates communication between the parent and child processes using the socket. The parent process writes a message to the socket, while the child process reads from it after writing its own message. The program utilizes system calls such as `socket()` to create the socket, `fork()` to create the child process, and `send()` and `recv()` to send and receive data through the socket. This example serves as an educational tool for understanding sockets and their practical application in C programming.

### Key Features:
- Demonstrates the creation and use of sockets.
- Illustrates inter-process communication between a parent and child process over a network.
- Utilizes system calls for managing sockets (`socket()`, `fork()`, `send()`, `recv()`).
- Cleans up resources by closing the socket after use.

### Usage

```bash
# Compile the program
gcc socket.c -o socket
# Run the program
./socket
```

### Expected Output

```bash
# The socket should contain the messages sent by the parent and child processes.
Parent wrote: Hello from parent process!
        Child wrote: Hello from child process!
```

## 9.8 Exercises

1. Modify the `signals.c` program to handle multiple signals.
2. Modify the `semaphore.c` program to use a mutex instead of semaphores.
3. Modify the `shared_memory.c` program to use a shared memory segment for communication between multiple processes.
4. Modify the `message_queue.c` program to use a message queue for communication between multiple processes.
5. Modify the `pipe.c` program to use a pipe for communication between multiple processes.
6. Modify the `fifo.c` program to use a FIFO for communication between multiple processes.
7. Modify the `socket.c` program to use a socket for communication between multiple processes over a network.

These exercises will help you gain a deeper understanding of inter-process communication (IPC) mechanisms in Unix-like operating systems.

## 9.9 Conclusion

In this chapter, we have explored various inter-process communication (IPC) mechanisms in Unix-like operating systems. We have covered signals, semaphores, shared memory, message queues, pipes, FIFOs, and sockets. Each mechanism has its own unique features and use cases, and understanding these mechanisms is essential for developing robust and efficient multi-process applications.
